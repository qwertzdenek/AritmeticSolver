\documentclass[a4paper, 12pt]{article}

\usepackage{czech}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{url}
% \usepackage{a4wide}

\def\CS{$\cal C\kern-.1667em\lower.5ex\hbox{$\cal S$}\kern-.075em $}
\DeclareUrlCommand\url{\def\UrlLeft{<}\def\UrlRight{>} \urlstyle{tt}}

\usepackage{natbib}
\bibliographystyle{csplainnat}

\lstset{language=C}

\begin{document}
\begin{titlepage}
\includegraphics[bb=0 0 167 96]{fav_cmyk.pdf}
\vfill
\begin{center}
{\huge Programování v~jazyce C}\\[3ex]
{\Large Interpret podmnožiny jazyka LISP}
\end{center}
\vfill
\begin{tabbing}
Vypracoval: \hspace{1ex}\=Zdeněk Janeček\kill
Vypracoval: \>Zdeněk \textsc{Janeček}\\[1ex]
Datum:\> \today
\end{tabbing}
\end{titlepage}

\tableofcontents

\section{Zadání}
Naprogramujte v~ANSI C přenositelnou \emph{konzolovou aplikaci}, která
bude fungovat jako jednoduchý interpret podmnožiny jazyka LISP.
Vstupem budou příkazy v~jazyce LISP. Výstupem pak výsledek vyhodnocení
každého výrazu.

Program se bude spouštět příkazem \textsf{lisp.exe
  [\textless{}vstupní-soubor\textgreater{}]}. Symbol
\textsf{\textless{}vstupní-soubor\textgreater{}} zastupuje nepovinny
parametr -- název vstupního souboru se seznamem výrazů v~jazyce
LISP. Není-li první parametr uveden, program bude fungovat
v~interaktivním módu, kdy se příkazy budou provádět přímo zadáním
z~konzole do programu.

Úkolem Vámi vyvinutého programu tedy je:
\begin{enumerate}
\item Při spuštění bez parametru bude čekat na vstup od uživatele.
  Zadaný výraz vyhodnotí a bude vyžadovat další vstup, dokud nebude
  uveden výraz \texttt{(quit)}.
\item Při spuštění s~parametrem načte zadaný vstupní soubor, každý
  výraz v~něm uvedený vypíše na obrazovku, okamžitě vyhodnotí a
  výsledek vypíše na obrazovku. Po zpracování posledního výrazu dojde
  k~ukončení programu. Proto nemusí být jako poslední výraz uveden
  výraz \texttt{(quit)}. Na jedné řádce v~souboru může být uvedeno
  více samostatných výrazů a program je musí být schopen správně
  zpracovat.
\end{enumerate}

Váš program může být během testování spuštěn například takto:
\begin{verbatim}
  $ lisp.exe test.lisp
\end{verbatim}

Hotovou práci odevzdejte uploadem na server podle pokynů na webu, v~archivu
ZIP, pojmenovaném Vaším osobním číslem. Archiv nechť obsahuje všechny
zdrojové soubory potřebné k~přeložení programu, \textsf{makefile} pro
Windows i Linux (pro překlad v~UNIXu/Linuxu připravte soubor pojmenovaný
\textsf{Makefile} a pro Windows \textsf{Makefile.win}) a dokumentaci ve
formátu PDF vytvořenou v~typografickém systému \TeX{}, resp. \LaTeX{}.
Bude-li některá z~částí chybět, kontrolní skript Vaši práci odmítne.

\section{Problematika}
Každý programovací popisujeme gramatikou jako každý jiný jazyk.
Prefixový zápis celou věc zjednodušuje, narozdíl od běžného infixového
zápisu. LISP nám už v~historii ukázal že lze programovat lehce jinak.
Totiž, že vše je seznamem.

\subsection{Lexikální analýza}
Při návrhu programu jsem se řídil jednoduchou gramatikou, která je
naznačena na obrázku \ref{fig:gram}. Každý neterminální symbol značený
velkými písmeny představuje jednu funkci v~programu. Terminální symboly
jsou: \emph{č} jako číslo, \emph{op} jako operátor, * je identifikátor
proměnné.

\begin{figure}
\centering
\begin{tabular}{r@{$\quad\longrightarrow\quad$}l}
START & VÝRAZ $|$ KOMP\\
VYRAZ & op \{KOMP\}\\
KOMP & č $|$ IDENT $|$ (VYRAZ) $|$ (KOMP)\\
IDENT & QUOTE $|$ quit $|$ set $|$ car $|$ *\\[1ex]
QUOTE & QKOMP $|$ KOMP\\
QKOMP & č $|$ op $|$ * $|$ (QLIST)\\
QLIST & \{QKOMP\}

\end{tabular}

\caption{Gramatika zadaného jazyka.}
\label{fig:gram}
\end{figure}

Jakmile jsem měl k~dispozici gramatiku, nic mi nebránilo sepsat
syntaktický analyzátor. Ještě před tím jsem využil zkušeností a pustil
se na lexikální analýzu.  Potřeboval jsem něco, co mi bude rozlišovat
typy lexikálních atomů. Detekuji tedy atomy, definované
v~\texttt{lexa.h} (tabulka \ref{tab:atom}).

\begin{table}
\centering
\begin{tabular}{|r|l|}
\hline
Název & Popis\\ \hline\hline
AT\_UNKNOWN & Neznámý\\ \hline
AT\_OPERATOR & Aritmetický operátor\\ \hline
AT\_IDENT & Název proměnné/příkazu\\ \hline
AT\_VALUE & Celočíselná hodnota\\ \hline
AT\_LBRACKET & Otevírací závorka\\ \hline
AT\_RBRACKET & Zavírací závorka\\
\hline
\end{tabular}
\caption{Rozeznávané atomy}
\label{tab:atom}
\end{table}

K~získávání atomů slouží funkce \verb+lexa_next(atom *sym)+.  Dostávám
tedy rovnou parsovaná data ve formě struktury \texttt{atom}.  Ta
vypadá takto:
\begin{lstlisting}
typedef struct {
  unsigned char type;
  char data[32];
} atom;
\end{lstlisting}

Že je to dobrý nápad jsem se přesvědčil velice rychle. Získáním
jednotlivých symbolů dostávám rovnou řetězce. To dovoluje snadné
rozhodování a kód se zkracuje. Hodí se využít rekurzivního
volání jelikož k~tomu sama gramatika vybízí.
Nevyužívám současně žádnou dynamicky alokovanou paměť.

Jakmile začínáme vyhodnocovat nový příkaz, musí se nejprve lexikální
analyzátor inicializovat funkcí
\verb+void lexa_init(char*strin)+, která vynuluje aktuální atom a
nastaví vnitřní ukazatel na řetězec \texttt{static char *ptr}. Tento
ukazatel se posouvá v~závislosti na datech a výsledné kusy kopíruji do pole
\texttt{data} vyšetřovaného atomu. Například můžu uložit celočíselnou
hodnotu přímo:

\begin{lstlisting}
if (isdigit(*ptr))
{
  ival = (int) strtol(ptr, &ptr, 10);
  csym.type = AT_VALUE;
  memcpy(csym.data, &ival, sizeof(int));
}
\end{lstlisting}

Řetězec uložím i s~ukončujícím nulovým znakem.  Rozdíl konečného
ukazatele a počátečního dává počet prvků.

\begin{lstlisting}
if (is_operator(*ptr))
{
  tptr = ptr;
  while (is_operator(*ptr))
    ptr++;
  csym.type = AT_OPERATOR;
  memcpy(csym.data, tptr, ptr - tptr);
  *(csym.data + (ptr - tptr)) = 0;
}
\end{lstlisting}

Funkce \texttt{is\_operator(char o)} vrací \texttt{true} když
je symbol operátor. Nyní máme vytvořený symbol \texttt{csym}, ten
stačí nakopírovat na místo, které nám bylo dodáno zvenčí.

Aktuální, symbol dostaneme voláním
\verb+void lexa_get(atom *sym)+. Tím se analyzátor nikam nepřesouvá.
Pořadí volání funkcí je následující: \texttt{init}, \texttt{next} a
libovolně \texttt{get}.

Často využívám dvě funkce z~modulu \texttt{tools.h}. První porovná
dva řetězce
\verb+bool equals(char *compared, const char *to, int stripit)+. Návratový
typ \texttt{bool} pochází z~knihovny \texttt{stdbool.h}.  Poslední
parametr \texttt{stripit} říká, zda je nutné oříznout počáteční a
koncové bílé znaky z~řetězce \texttt{compared}.  Druhá je velmi
jednoduchá funkce \verb+void die(const char *msg)+. Ta správně ukončí celý
program a vypíše chybovou zprávu.

\subsection{Syntaktická analýza}
Každý zpracovávaný vstup začíná funkcí \texttt{start()} z~modulu
\textsf{synta}.  Výsledkem této funkce je buď 1 nebo 0. To značí, zda
se má číst další vstup.  Zásadní funkce jsou
\verb+void vyraz(char *out)+ a \verb+void komp(char *res)+. Podle
gramatiky už je zjevné jaké vstupy zpracovávají.

Aritmetické výrazy byly dvojího typu. Buď aritmetické nebo
booleovské. Každý aritmetický výraz je vyhodnocen zleva doprava
postupným aplikováním operátoru na prvním místě. Musel jsem tedy na
počátku zvolit neutrální prvek k~této operaci. Spočtená hodnota se
ukládá do mezi-proměnné a nakonci tam zůstane výsledek.  Využil jsem
s~výhodou datový typ ukazatel na funkci.

Každý operátor má svou vlastní funkci jako tato:
\begin{lstlisting}
int addii(int a, int b)
{
  return a + b;
}
\end{lstlisting}

Podle toho jaký operátor funkce \texttt{vyraz(char *out)} najde,
přiřadí příslušný ukazatel na funkci \verb+int (*op)(int, int)+.

Samotné vyhodnocování je pouze tento krátký cyklus:
\begin{lstlisting}
lexa_next(&act);
while (act.type == AT_VALUE || act.type == AT_IDENT ||
          act.type == AT_LBRACKET)
  {
    if (type == ARIT)
      {
        komp(buf);
        res = op(res, strtol(buf, NULL, 10));
      }
    else if (type == BOOL)
      {
        komp(buf);
        bres &= op(res, strtol(buf, NULL, 10));
      }
    if (!lexa_next(&act))
      break;
  }
\end{lstlisting}

Zpracování jedné komponenty zabralo spoustu kódu.  Zjišťuje se o~jaký
atom se jedná a tudíž je zde spoustu možností. Vyhodnocují se
v~následujícím pořadí:
\begin{itemize}
\item číslo
\item závorkovaný výraz
\item identifikátor
\begin{itemize}
\item QUIT
\item SET
\item CAR
\item CDR
\item QUOTE
\item HELP
\item LIST
\item NIL
\item proměnná
\end{itemize}

\end{itemize}

Číslem se rozumí triviální vstup čísla. Závorkovaný výraz zavolá
rekurzivně výraz, nebo další komponentu. Jednotlivé identifikátory představují
vnitřní příkazy interpretu až na poslední možnost, kdy se vyhledá
proměnná v~seznamu uložených proměnných.

Porovnávání názvu identifikátoru zajišťuje funkce \texttt{equals} a
vyzkouším postupně všechny možné řetězce. Nastavení hodnoty proměnné
vypadá jednoduše.

\begin{lstlisting}
if (equals(act.data, set, 0))
  {
    lexa_next(NULL);
    komp(res);
    var_n = (char *) malloc(strlen(res) + 1);
    strcpy(var_n, res);

    lexa_next(NULL);
    komp(res);
    var_v = (int *) malloc(sizeof(int));
    *var_v = strtol(res, NULL, 10);
	  
    push(var_v, var_n);
  }
\end{lstlisting}

Při změně hodnoty která v~seznamu již je, nepotřebuji najít a mazat
starou hodnotu. Protože přidávám vždy na konec a prohledávám odzadu,
starou hodnotu nikdy nenajdu. Do seznamu vkládám v~konstantním čase.

\section{Používání}
K~překladu aplikace není třeba žádné zvláštní závislosti. Potřeba je
pouze překladač jazyka C. Testován byl pouze překladač \textsf{GCC}.
Přibalen je soubor \textsf{Makefile}. Po překladu pomocí programu
\textsf{make} vznikne spouštěcí soubor \textsf{lisp}.

Aplikace je čistě konzolová. Funguje buď interaktivně, nebo
dávkově. Spustí-li se aplikace bez parametru, bude čekat na vstup
uživatele. Každý příkaz oddělí uživatel stisknutím klávesy ENTER.

Výstup pak vypadá nějak takto:
\begin{verbatim}
[1]> (set 'a 12)
12
[2]> (set 'x1 2)
2
[3]> (set 'x2 (* x1 2))
4
[4]> (* x1 x2)
8
[5]> (list a x1 x2)
(12 2 4)
\end{verbatim}

Program skončí se zadáním \texttt{(quit)}. Pokud jste líní funguje i
\texttt{quit} bez ozávorkování. Již jsem se zmínil během popisu funkce
\texttt{komp()} jaké příkazy jsou podporovány. V~tabulce \ref{tab:prik}
se můžete dočíst o~podporovaných příkazech.

\begin{table}
\centering
\begin{tabular}{|r|l|}
\hline
quote & argument nebude vyhodnocen\\ \hline
list & argumenty budou vráceny jako seznam\\ \hline
car & vrátí první prvek seznamu\\ \hline
cdr & vrátí seznam bez prvního prvku\\ \hline
set & uloží hodnotu proměnné\\ \hline
quit & ukončí program\\ \hline
help/about & vypíše informace o~autorovi a licenci\\
\hline
\end{tabular}
\caption{Podporované příkazy interpretu}
\label{tab:prik}
\end{table}

Dále je jsou k~dispozici klasické operátory. Všechny operátory se
zapisují prefixově. To znamená že prvním symbolem je operátor a pak
následují všechny následující, na které se postupně aplikuje operace.
Seznam podporovaných operátor je v~tabulce \ref{tab:op}.

\begin{table}
\centering
\begin{tabular}{|r|l|}
\hline
+ & sečte vrátí výsledek\\ \hline
- & vezme první a postupně odečítá\\ \hline
* & vynásobí a vrátí výsledek\\ \hline
/ & vemen první a postupně dělí\\ \hline
= & testuje na rovnost všech\\ \hline
/= & testuje na nerovnost\\ \hline
\textgreater{} & testuje zda jsou prvky menší než předchozí\\ \hline
\textless{} & testuje zda jsou prvky větší než předchozí\\ \hline
\textgreater{=} & jako v~minulém, ale současně na rovnost\\ \hline
\textless{=} & jako v~minulém, ale současně na rovnost\\ \hline
\end{tabular}
\caption{Podporované operátory}
\label{tab:op}
\end{table}

Na závěr mám přichystané malé překvapení, protože umí odpovědět i
na největší otázku. Zkuste napsat slavnou větu \texttt{What is the
meaning of live, The Universe and Everything?}.

\section{Závěr}
Programování v~tomto jazyce má mnoho úskalí a snadno se stalo že něco
prostě nešlo. Pod výsledek se ale rád podepíšu, protože se ukázaly i velké
výhody tohoto jazyka, které jsem rád využil. Mohu alokovat kus paměti,
který využívám po celou dobu běhu programu. Konec řetězce zajistím pouhým
zapsáním nulového znaku. Ve vyšších jazycích je nemyslitelné, že dokonce
nemusím ukládat do řetězce jen řetězce, ale i jakákoli jiná data, když vím
že tam budou. Třeba zapsat strukturu do řetězce.

Do budoucna by program vyžadoval přidat možnost rozšiřování na další
příkazy. Veškeré mé funkce byly natvrdo nakódovány a přidat např.
funkci na vrácení počtu prvků v~seznamu by vyžadovalo další zvětšování
modulu \textsf{synta}. Ten by se měl rozdělit do několika podprogramů.

Program vznikal na více místech. Byl to ArchLinux na procesoru x86 a
pak Debian na Raspberry Pi. Vyzkoušel jsem tedy i funkčnost na tomto
RISC procesoru s~architekturou ARMv6.

Textové editory jsem používal 2. Byl to Emacs a Geany. Vyzkoušel jsem si i
práci s~debuggerem \textsf{gdb} a vyhodnotil případné problémy v~programu
\textsf{valgrind}. Dokumentace byla napsána v mém oblíbeném systému
\CS\LaTeX{}. Protože jsem dělal minimálně na dvou počítačích, verzoval jsem
na GitHubu na adrese
\url{https://github.com/qwertzdenek/AritmeticSolver}. Program bude dále
veřejně dostupný pod licencí GNU GPL verze 3.

\nocite{wiki:cpro}
\nocite{pred:c}
\bibliography{zdroje}
\end{document}
