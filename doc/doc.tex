\documentclass{article}

\usepackage{czech}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{listings}

\lstset{language=C}

\begin{document}
\begin{titlepage}
\includegraphics[width=30ex]{fav_cmyk}
\vfill
\begin{center}
{\huge Programování v jazyce C}\\[2ex]
{\Large Interpret podmnožiny jazyka LISP}
\end{center}
\vfill
\begin{tabbing}
Vypracoval: \hspace{1ex}\=Zdeněk Janeček\kill
Vypracoval: \>Zdeněk \textsc{Janeček}\\
Datum:\> \today
\end{tabbing}
\end{titlepage}

\section{Problematika}
Každý programovací popisujeme gramatikou jako každý jíný jazyk.
Prefixový zápis celou věc zjednodušuje, narozdíl od běžného přístupu.
LISP nám už v historii ukázal že lze programovat lehce jinak.  Totiž,
že vše je seznamem.

Při návrhu programu jsem se řídil jednoduchou gramatikou, která je na
obrázku \ref{fig:gram}. Každý neterminální symbol značený velkými
písmeny představuje jednu funkci. Terminální symboly jsou: \emph{č}
jako číslo, \emph{op} jako operátor, * je identifikátor proměnné.

\begin{figure}
\centering
\begin{tabular}{r@{$\quad\longrightarrow\quad$}l}
START & VÝRAZ $|$ KOMP\\
VYRAZ & op KOMP RETEZ\\
KOMP & č $|$ IDENT $|$ (VYRAZ) $|$ (KOMP)\\
RETEZ & KOMP RETEZ $|$ KOMP\\
IDENT & QUOTE $|$ quit $|$ set $|$ car $|$ *\\[1ex]
QUOTE & QSYM QRETEZ\\
QRETEZ & QUOTE $|$ QSYM\\
QSYM & (QUOTE) $|$ č $|$ * $|$ op
\end{tabular}

\caption{Gramatika zadaného jazyka.}
\label{fig:gram}
\end{figure}

Jakmile jsem měl k dispozici gramatiku, nic mi nebránilo sepsat
syntaktický analyzátor. Ještě před tím jsem využil zkušeností a vrhnul
se na lexikální analýzu.  Potřeboval jsem něco, co mi bude rozlišovat
typy lexikálních atomů. Detekuji tedy atomy, definované v
\texttt{lexa.h} (tabulka \ref{tab:atom}).

\begin{table}
\centering
\begin{tabular}{|r|l|}
\hline
Název & Popis\\ \hline\hline
AT\_UNKNOWN & Neznámý\\ \hline
AT\_OPERATOR & Aritmetický operátor\\ \hline
AT\_IDENT & Název proměnné/příkazu\\ \hline
AT\_VALUE & Celočíselná hodnota\\ \hline
AT\_LBRACKET & Otevírací závorka\\ \hline
AT\_RBRACKET & Zavírací závorka\\
\hline
\end{tabular}
\caption{Rozeznávané atomy}
\label{tab:atom}
\end{table}

K získávání atomů slouží funkce \verb+lexa_next(char *sym)+.  Dostávám
tedy rovnou parsovaná data ve formě struktury \texttt{atom}.  Ta
vypadá takto:
\begin{lstlisting}
typedef struct {
  unsigned char type;
  char data[32];
} atom;
\end{lstlisting}

Že je to dobrý nápad jsem se přesvědčil velice rychle. Voláním
jednotlivých symbolů dostávám řetězce s výsledkem. To dovoluje
snadné kombinování funkcionality. Hodí se tedy využít rekurzivního
volání. Nevyužívám tím žádnou dynamicky alokovanou paměť.

Pozici ve vstupním řetězci mám uloženou v proměnné \texttt{*ptr}.
Ta se posouvá a výsledné kusy kopíruji do pole \texttt{data}
vyšetřovaného atomu. Ten vždy přepíši novými daty a mám
jeden datový prostor po celou dobu. Například můžu uložit celočíselnou
hodnotu přímo:

\begin{lstlisting}
if (isdigit(*ptr))
  {
    ival = (int) strtol(ptr, &ptr, 10);
    csym.type = AT_VALUE;
    memcpy(csym.data, &ival, sizeof(int));
  }
\end{lstlisting}

Když jde o řetězec, uložím ho i s ukončujícím nulovým znakem.

\begin{lstlisting}
if (is_operator(*ptr))
  {
    tptr = ptr;
    while (is_operator(*ptr))
      ptr++;
    csym.type = AT_OPERATOR;
    memcpy(csym.data, tptr, ptr - tptr);
    *(csym.data + (ptr - tptr)) = 0;
}
\end{lstlisting}

Funkce \texttt{is\_operator(char o)} je jednoduchá:

\begin{lstlisting}
bool is_operator(char o)
{
  if (o == '+' || o == '*' || o == '-' || o == '/' ||
      o == '=' || o == '<' || o == '>')
    return true;
  else
    return false;
}
\end{lstlisting}

Často využívám dvě metody z modulu \texttt{tools.h}. První porovnává
dva řetězce s hlavičkou
\verb+bool equals(char *compared, const char *to, int stripit)+. Návratový
typ \texttt{bool} pochází z knihovny \texttt{stdbool.h}.
Poslední parametr \texttt{stripit} říká zda je nutné oříznout
počáteční a koncové bílé znaky z \texttt{compared} řetězce.
Druhá je velmi jednochá funkce \verb+void die(const char *msg)+. Ta čistě
ukončí celý program a vypíše chybovou zprávu.

Každý zpracovávaný vstup začíná funkcí \texttt{start()}.  Výsledkem
této funkce je buď 1 nebo 0. To značí, zda se má číst další vstup.
Další zásadní funkce jsou \verb+void vyraz(char *out)+ a
\verb+void komp(char *res)+. Podle gramatiky už je zjevné jaké
vstupy zpracovávají.

Aritmetické výrazy byly dvojího typu. Buď aritmetické nebo
booleovské. Každý aritmetický výraz je vyhodnocen zleva doprava
postupným aplikováním operátoru na prvním místě. Musel jsem
tedy na počátku zvolit neutrální prvek k této operaci. Spočtená
hodnota se ukládá do meziproměnné a nakonci tam zůstane výsledek.
Využil jsem s výhodou datový typ ukazatel na funkci.

Každý operátor má svou vlastní funkci jako tato:
\begin{lstlisting}
int addii(int a, int b)
{
  return a + b;
}
\end{lstlisting}

Podle toho jaký operátor funkce \texttt{vyraz(char *out)}
najde, přiřadí příslušný ukazatel na funkci \verb+int (*op)(int, int)+.

Samotné vyhodnocování je pouze tento krátký cyklus:
\begin{lstlisting}
lexa_next(&act);
while (act.type == AT_VALUE || act.type == AT_IDENT ||
          act.type == AT_LBRACKET)
  {
    if (type == ARIT)
      {
        komp(buf);
        res = op(res, strtol(buf, NULL, 10));
      }
    else if (type == BOOL)
      {
       komp(buf);
       bres &= op(res, strtol(buf, NULL, 10));
      }
    if (!lexa_next(&act))
      break;
  }
\end{lstlisting}

\section{Používání}
Aplikace je čistě konzolová. Funguje buď interaktivně, nebo
dávkově.

\section{Závěr}
Programování v tomto jazyce má
mnoho úskalí a snadno se stalo že něco prostě nešlo. Pod výsledek se
ale rád podepíšu, protože se ukázali i velké výhody tohoto jazyka, které
jsem rád využil.

Program vznikal na více místech. Byl to ArchLinux na procesoru x86 a
pak Debian na Raspberry Pi. Vyzkoušel jsem tedy i funkčnost na tomto
RISC procesoru s architekturou ARMv6.

Editory jsem používal 2. Byl to Emacs a Geany. Vyzkoušel jsem si
i práci s debuggerem \textsf{gdb} a vyhodnotil případné problémy
ve \textsf{valgrind}. Zvolil jsem netradiční GNU coding style.

\end{document}
