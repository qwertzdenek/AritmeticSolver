\documentclass{article}

\usepackage{czech}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{listings}

\begin{document}
\begin{titlepage}
\includegraphics[width=30ex]{fav_cmyk}
\vfill
\begin{center}
{\huge Programování v jazyce C}\\[2ex]
{\Large Interpret podmnožiny jazyka LISP}
\end{center}
\vfill
\begin{tabbing}
Vypracoval: \hspace{1ex}\=Zdeněk Janeček\kill
Vypracoval: \>Zdeněk \textsc{Janeček}\\
Datum:\> \today
\end{tabbing}
\end{titlepage}

\section{Problematika}
Každý programovací popisujeme gramatikou jako každý jíný jazyk.
Prefixový zápis celou věc zjednodušuje, narozdíl od běžného přístupu.
LISP nám už v historii ukázal že lze programovat lehce jinak.  Totiž,
že vše je seznamem.

Při návrhu programu jsem se řídil jednoduchou gramatikou, která je na
obrázku \ref{fig:gram}. Každý neterminální symbol značený velkými
písmeny představuje jednu funkci. Terminální symboly jsou: \emph{č}
jako číslo, \emph{op} jako operátor, * je identifikátor proměnné.

\begin{figure}
\centering
\begin{tabular}{r@{$\quad\longrightarrow\quad$}l}
START & VÝRAZ $|$ KOMP\\
VYRAZ & op KOMP RETEZ\\
KOMP & č $|$ IDENT $|$ (VYRAZ) $|$ (KOMP)\\
RETEZ & KOMP RETEZ $|$ KOMP\\
IDENT & QUOTE $|$ quit $|$ set $|$ car $|$ *\\[1ex]
QUOTE & QSYM QRETEZ\\
QRETEZ & QUOTE $|$ QSYM\\
QSYM & (QUOTE) $|$ č $|$ * $|$ op
\end{tabular}

\caption{Gramatika zadaného jazyka.}
\label{fig:gram}
\end{figure}

Jakmile jsem měl k dispotici gramatiku, nic mi nebránilo sepsat
syntaktický analyzátor. Ještě před tím jsem využil zkušeností a vrhnul
se na lexikální analýzu.  Potřeboval jsem něco, co mi bude rozlišovat
typy lexikálních atomů. Detekuji tedy atomy, definované v
\texttt{lexa.h} (tabulka \ref{tab:atom}).

\begin{table}
\centering
\begin{tabular}{|r|l|}
\hline
Název & Popis\\ \hline\hline
AT\_UNKNOWN & Neznámý\\ \hline
AT\_OPERATOR & Aritmetický operátor\\ \hline
AT\_IDENT & Název proměnné/příkazu\\ \hline
AT\_VALUE & Celočíselná hodnota\\ \hline
AT\_LBRACKET & Otevírací závorka\\ \hline
AT\_RBRACKET & Zavírací závorka\\
\hline
\end{tabular}
\caption{Rozeznávané atomy}
\label{tab:atom}
\end{table}

K získávání atomů slouží funkce \verb+lexa_next(char *sym)+.  Dostávám
tedy rovnou parsovaná data ve formě struktury \texttt{atom}.  Ta
vypadá takto: \lstset{language=C}
\begin{lstlisting}
typedef struct {
  unsigned char type;
  char data[32];
} atom;
\end{lstlisting}

Že je to dobrý nápad jsem se přesvědčil velice rychle. Voláním
jednotlivých symbolů dostávám řeťezce s výsledkem. To dovoluje
snadné kombinování funkcionality. Hodí se tedy využít rekurzivního
volání. Nevyužívám tím žádnou dynamicky alokovanou paměť.

Často využívám dvě metody z modulu \texttt{tools.h}. První porovnává
dva řetězce s hlavičkou
\verb+bool equals(const char *compared, const char *to)+. Návratový
typ \texttt{bool} pochází z knihovny \texttt{stdbool.h}. Druhá je
velmi jednochá funkce \verb+void die(const char *msg)+. Ta čistě
ukončí celý program a vypíše chybovou zprávu.

Každý zpracovávaný vstup začíná funkcí \texttt{start()}.  Výsledkem
této funkce je buď 1 nebo 0. To značí zda se má číst další vstup.
Další zásadní funkce jsou \verb+void vyraz(char *out)+ a
\verb+void komp(char *res)+. Podle gramatiky už je zjevné jaké
vstupy zpracovávají.

Aritmetické výrazy byly dvojího typu. Buď aritmetické nebo
booleovské. Každý aritmetický výraz je vyhodnocen zleva doprava
postupným aplikováním operátoru na prvním místě. Musel jsem
tedy na počátku zvolit neutrální prvek k této operaci. Spočtená
hodnota se ukládá do meziproměnné a nakonci tam zůstane výsledek.
Využil jsem s výhodou datový typ ukazatel na funkci.

\section{Používání}
Aplikace je čistě konzolová. Funguje buď interaktivně, nebo
dávkově.

\section{Závěr}
Hodnocení této práce je jednoduché. Programování v tomto jazyce má
mnoho úskalí a snadno se stalo že něco prostě nešlo. Pod výsledek se
rád podepíšu.

Program vznikal na více místech. Byl to ArchLinux na procesoru x86 a
pak Debian na Raspberry Pi. Vyzkoušel jsem tedy i funkčnost na tomto
RISC procesoru s architekturou ARMv6

\end{document}
